# Artifact

## Overview

For our ICSE 25 paper ["Invivo Fuzzing by Amplifying Actual Executions"](https://mpi-softsec.github.io/papers/ICSE25-invivo.pdf) we tested `afllive` on 12 subjects. Out of these 12, 9 were tested using a host program that made use of the library, and the remaining 3 had their test-suites amplified.
Additionally, in Section VI.B, we evaluated the effectiveness of our tool when using the set of amplifier points and constraints automatically identified by our static analysis without manual augmentation.
When available, we compared the performance of our prototype to that of fuzz drivers generated by state-of-the-art approaches.

In this directory we provide docker containers to reproduce these fuzzing campaigns, and to measure the code-coverage achieved by each campaign.
For the fuzzing campaigns using `afllive`, we provide both the configuration file produced by our static analysis, and the manually augmented one, so as to allow reproduction of our ablation study.

## Running

The scripts `run_afllive.sh` and `run_sota.sh` present in this directroy reproduce the fuzzing campaigns used in our experimentation.
They will create a docker image for the specified fuzzing campaign, allow it to run for an arbitrary amount of time, and copy the results to the output directory.
Afterwards, they'll create a second docker image (identical to the first, except for the fact that it compiles the code with the `-fprofile-instr-generate -fcoverage-mapping` flags), which will iterate over the previously generated corpus (making use of a docker volume to give the container access to it) and use the scripts present in the [coverage\_utils directory](../coverage_utils/) to report coverage measured at 10 minutes intervals.
After both containers are run, the results are copied to the host and they're erased.

> Before running, both scripts will invoke `prepare_host_for_fuzzing.sh`, which sets up a number of settings to allow for more performant fuzzing. Additionally, on Linux hosts, the variable `vm.mmap_rnd_bits` is set to 28 in order to work around a bug present in old versions of LLVM which could result in suprious crashes when using ASAN.

The `Dockerfile`s and scripts specifying the configuration for each fuzzing campaign are stored under the `sota/${SUBJECT}` and `afllive/${SUBJECT}` directories.
The `Dockerfile`s and scripts specifying how code coverage is measured are stored under the `sota/${SUBJECT}/coverage` and `afllive/${SUBJECT}/coverage` directories.

### `afllive`

In order to run a campaign using `afllive`, use:

```
./run_afllive.sh [project] [generated|curated] [output_path] [campaign duration in seconds]
```

Where `generated`/`curated` specifies whether the automatically generated or manually augmented configuration file should be used, respectively.
Valid values for `project` are: `boringssl`, `bzip2` (`curated` only), `htslib`, `leptonica`, `libaom`, `libass`, `libexif` (`curated` only), `libgsm` (`curated` only), `libvpx`, `libxml2`, `openssl` and `opus`.
Note that in the cases where the static analysis failed to identify suitable amplifier points, only the `curated` version will run successfully.

For instance, the following runs a fuzzing campaign on `leptonica` for one minute using the automatically infered amplification points/constraints, storing the results in `$PWD/results`:

```
./run_afllive.sh leptonica generated results 60
```

> Note that if specifying an output path under `/tmp/` can cause problems when running on Ubuntu if `docker` is installed as a snap.

> If you have cloned this repository from the Software Heritage Archive the path to this folder most likely contains a colon (`:`). Paths with colons in them can't be mounted as volumes to `Docker` containers, and so running this script in such a circumstance would result in a failure. As such, please make to run this from a directory without colons in its absolute path.

### State of the Art

In order to run a campaign using the state-of-the-art alternative (`FUDGE` or `FuzzGen`, depending on the subject), use:

```
./run_sota.sh [project] [output_path] [campaign duration in seconds]
```

Valid values for `project` are: `htslib` and `leptonica` for `FUDGE`, `libaom`, `libgsm` and `libvpx` for `FuzzGen`.

Similarly, the following runs a fuzzing campagin on `leptonica` (using `FUDGE`) for one minute:

```
./run_sota.sh leptonica results 60
```

> Note that `FuzzGen`'s fuzz drivers generate numerous OOM errors which, although they are reported as crashes, are bugs in the fuzz drivers and not in the underlying library.
Only files named `crash-*` are counted as crashes.

## Results

The corpus, set of crashes, and coverage reports obtained from the fuzzing campaign will be available on the output path.
Since our tool is based on AFL++, and the state-of-the-art approaches use libfuzzer, we have streamlined the layout of the output directory to mimic that of AFL++ in both cases.
This means that `${OUTPUT_PATH}/out/default/crashes` will contain crashes encountered during the campaign, and `${OUTPUT_PATH}/out/default/queue` will contain the corpus.

Code-coverage will be stored in the file `${OUTPUT_PATH}/coverage_${SUBJECT}_0.txt`, where the structure of the file is:

```
${SUBJECT}_iter_0@${WINDOW}: ${COVERAGE}/${TOTAL}
```

Where `${WINDOW}` is the 10-minute window being considered, `${COVERAGE}` is the coverage achieved by the fuzzer, and `${TOTAL}` is the total amount of lines of code in the project (note that we do not cound the host application nor the fuzz driver in these figures).

